<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¨¡å‹æ˜ å°„ç®¡ç† - NewAPI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .mapping-row:hover { background-color: #f9fafb; }
        .mapping-row.checked { background-color: #eff6ff; }
        .drag-handle { cursor: grab; }
        .drag-handle:active { cursor: grabbing; }
        .drag-over { border: 2px dashed #3b82f6; background-color: #eff6ff; }
        .fade-in { animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-4px); } to { opacity: 1; transform: translateY(0); } }
        .slide-in { animation: slideIn 0.3s ease-out; }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div id="app" class="container mx-auto px-4 py-8 max-w-6xl">
        <!-- å¤´éƒ¨å·¥å…·æ  -->
        <div class="bg-white rounded-lg shadow-sm p-4 mb-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-4">
                    <h1 class="text-xl font-semibold text-gray-800">æ¨¡å‹æ˜ å°„ç®¡ç†</h1>
                    <select id="channelSelect" class="border border-gray-300 rounded px-3 py-1.5 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="">é€‰æ‹©æ¸ é“...</option>
                    </select>
                </div>
                <div class="flex items-center gap-2">
                    <button id="saveBtn" class="px-4 py-1.5 bg-blue-600 text-white rounded hover:bg-blue-700 transition text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed">
                        ä¿å­˜
                    </button>
                    <button id="resetBtn" class="px-4 py-1.5 border border-gray-300 rounded hover:bg-gray-50 transition text-sm">
                        é‡ç½®
                    </button>
                    <div class="h-6 w-px bg-gray-300 mx-2"></div>
                    <button id="importBtn" class="px-3 py-1.5 border border-gray-300 rounded hover:bg-gray-50 transition text-sm">
                        å¯¼å…¥
                    </button>
                    <button id="exportBtn" class="px-3 py-1.5 border border-gray-300 rounded hover:bg-gray-50 transition text-sm">
                        å¯¼å‡º
                    </button>
                </div>
            </div>
        </div>

        <!-- çŠ¶æ€æç¤ºåŒº -->
        <div id="statusBar" class="hidden mb-4 px-4 py-3 rounded-lg text-sm fade-in"></div>

        <!-- ä¸»å†…å®¹åŒº -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
            <!-- å·¦ä¾§: æ˜ å°„ç®¡ç† -->
            <div class="lg:col-span-2 space-y-4">
                <!-- å·¥å…·æ  -->
                <div class="bg-white rounded-lg shadow-sm p-4">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="checkbox" id="selectAll" class="w-4 h-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                                <span class="text-sm text-gray-700">å…¨é€‰</span>
                            </label>
                            <button id="inverseBtn" class="text-sm text-gray-600 hover:text-blue-600 transition">åé€‰</button>
                            <button id="deleteSelectedBtn" class="text-sm text-red-600 hover:text-red-700 transition disabled:opacity-50" disabled>
                                åˆ é™¤é€‰ä¸­
                            </button>
                        </div>
                        <button id="addMappingBtn" class="px-3 py-1.5 bg-green-600 text-white rounded hover:bg-green-700 transition text-sm font-medium">
                            + æ·»åŠ æ˜ å°„
                        </button>
                    </div>
                </div>

                <!-- æ˜ å°„è¡¨æ ¼ -->
                <div class="bg-white rounded-lg shadow-sm overflow-hidden">
                    <table class="w-full">
                        <thead class="bg-gray-100 border-b border-gray-200">
                            <tr>
                                <th class="w-10 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"></th>
                                <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-5/12">æºæ¨¡å‹</th>
                                <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-1/12"></th>
                                <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-5/12">ç›®æ ‡æ¨¡å‹</th>
                                <th class="w-20 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody id="mappingTableBody" class="divide-y divide-gray-200">
                            <!-- æ˜ å°„è¡Œå°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                        </tbody>
                    </table>
                    <div id="emptyState" class="hidden px-4 py-12 text-center">
                        <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                        </svg>
                        <h3 class="mt-2 text-sm font-medium text-gray-900">æš‚æ— æ˜ å°„</h3>
                        <p class="mt-1 text-sm text-gray-500">ç‚¹å‡»"æ·»åŠ æ˜ å°„"å¼€å§‹åˆ›å»º</p>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§: è§„åˆ™é¢æ¿ -->
            <div class="space-y-4">
                <!-- æ™ºèƒ½è§„åˆ™ -->
                <div class="bg-white rounded-lg shadow-sm p-4">
                    <h2 class="text-sm font-semibold text-gray-800 mb-3">æ™ºèƒ½è§„åˆ™</h2>
                    <div class="space-y-3">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="prefixCleanup" checked class="w-4 h-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                            <span class="text-sm text-gray-700">æ¸…ç†å‰ç¼€ [xxx] ã€xxxã€‘ (xxx) &lt;xxx&gt;</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="suffixCleanup" checked class="w-4 h-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                            <span class="text-sm text-gray-700">æ¸…ç†åç¼€ æ—¥æœŸ/ç‰ˆæœ¬/æ¸ é“æ ‡è¯†</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="wildcardMode" class="w-4 h-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                            <span class="text-sm text-gray-700">é€šé…ç¬¦æ¨¡å¼ Pro/* *DeepSeek* *</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="chainMapping" checked class="w-4 h-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                            <span class="text-sm text-gray-700">é“¾å¼æ˜ å°„ A â†’ B â†’ C</span>
                        </label>
                    </div>
                </div>

                <!-- è‡ªå®šä¹‰è§„åˆ™ -->
                <div class="bg-white rounded-lg shadow-sm p-4">
                    <div class="flex items-center justify-between mb-3">
                        <h2 class="text-sm font-semibold text-gray-800">è‡ªå®šä¹‰è§„åˆ™</h2>
                        <button id="addRuleBtn" class="text-sm text-blue-600 hover:text-blue-700 transition">+ æ·»åŠ </button>
                    </div>
                    <div id="customRulesList" class="space-y-2 max-h-48 overflow-y-auto">
                        <!-- è‡ªå®šä¹‰è§„åˆ™å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>

                <!-- é¢„è§ˆåŒº -->
                <div class="bg-white rounded-lg shadow-sm p-4">
                    <div class="flex items-center justify-between mb-3">
                        <h2 class="text-sm font-semibold text-gray-800">é¢„è§ˆå·®å¼‚</h2>
                        <span id="previewCount" class="text-xs text-gray-500">0 å¤„å˜æ›´</span>
                    </div>
                    <div id="previewArea" class="max-h-48 overflow-y-auto text-sm bg-gray-50 rounded p-3 font-mono text-xs">
                        æš‚æ— é¢„è§ˆ
                    </div>
                    <button id="previewBtn" class="mt-3 w-full px-3 py-1.5 border border-gray-300 rounded hover:bg-gray-50 transition text-sm">
                        é¢„è§ˆå˜æ›´
                    </button>
                </div>

                <!-- ä¸€é”®åº”ç”¨ -->
                <div class="bg-white rounded-lg shadow-sm p-4">
                    <h2 class="text-sm font-semibold text-gray-800 mb-3">ä¸€é”®åº”ç”¨</h2>
                    <div class="space-y-2">
                        <button id="checkpointBtn" class="w-full px-3 py-2 border border-gray-300 rounded hover:bg-gray-50 transition text-sm" disabled>
                            ğŸ“¦ åˆ›å»ºæ£€æŸ¥ç‚¹
                        </button>
                        <button id="syncBtn" class="w-full px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            ğŸš€ åŒæ­¥åˆ°æ¸ é“
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- æ·»åŠ /ç¼–è¾‘è§„åˆ™å¼¹çª— -->
    <div id="ruleModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md mx-4 fade-in">
            <div class="px-6 py-4 border-b border-gray-200">
                <h3 id="ruleModalTitle" class="text-lg font-semibold text-gray-800">æ·»åŠ è‡ªå®šä¹‰è§„åˆ™</h3>
            </div>
            <div class="px-6 py-4 space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">è§„åˆ™ç±»å‹</label>
                    <select id="ruleType" class="w-full border border-gray-300 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="string">ç²¾ç¡®åŒ¹é…</option>
                        <option value="prefix">å‰ç¼€åŒ¹é…</option>
                        <option value="suffix">åç¼€åŒ¹é…</option>
                        <option value="regex">æ­£åˆ™è¡¨è¾¾å¼</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">åŒ¹é…æ¨¡å¼</label>
                    <input type="text" id="rulePattern" placeholder="ä¾‹å¦‚: gpt-4" class="w-full border border-gray-300 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">ç›®æ ‡æ¨¡å‹</label>
                    <input type="text" id="ruleTarget" placeholder="ä¾‹å¦‚: gpt-4-turbo" class="w-full border border-gray-300 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
            <div class="px-6 py-4 border-t border-gray-200 flex justify-end gap-2">
                <button id="cancelRuleBtn" class="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50 transition text-sm">
                    å–æ¶ˆ
                </button>
                <button id="saveRuleBtn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition text-sm">
                    ä¿å­˜
                </button>
            </div>
        </div>
    </div>

    <!-- å¯¼å…¥å¼¹çª— -->
    <div id="importModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md mx-4 fade-in">
            <div class="px-6 py-4 border-b border-gray-200">
                <h3 class="text-lg font-semibold text-gray-800">å¯¼å…¥æ˜ å°„é…ç½®</h3>
            </div>
            <div class="px-6 py-4">
                <textarea id="importText" rows="8" placeholder="ç²˜è´´ JSON é…ç½®..." class="w-full border border-gray-300 rounded px-3 py-2 text-sm font-mono focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>
            </div>
            <div class="px-6 py-4 border-t border-gray-200 flex justify-end gap-2">
                <button id="cancelImportBtn" class="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50 transition text-sm">
                    å–æ¶ˆ
                </button>
                <button id="confirmImportBtn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition text-sm">
                    å¯¼å…¥
                </button>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script>
    // ==================== æ•°æ®æ¨¡å‹ ====================
    const StoreKey = 'newapi-model-mappings';

    const defaultState = {
        mappings: [],
        rules: {
            prefixCleanup: true,
            suffixCleanup: true,
            wildcardMode: false,
            chainMapping: true
        },
        customRules: []
    };

    let state = loadState();

    // ==================== æœ¬åœ°å­˜å‚¨ ====================
    function loadState() {
        try {
            const saved = localStorage.getItem(StoreKey);
            return saved ? JSON.parse(saved) : JSON.parse(JSON.stringify(defaultState));
        } catch (e) {
            console.error('åŠ è½½çŠ¶æ€å¤±è´¥:', e);
            return JSON.parse(JSON.stringify(defaultState));
        }
    }

    function saveState() {
        try {
            localStorage.setItem(StoreKey, JSON.stringify(state));
            showStatus('å·²ä¿å­˜', 'success');
        } catch (e) {
            console.error('ä¿å­˜çŠ¶æ€å¤±è´¥:', e);
            showStatus('ä¿å­˜å¤±è´¥', 'error');
        }
    }

    function resetState() {
        state = JSON.parse(JSON.stringify(defaultState));
        saveState();
        renderAll();
        showStatus('å·²é‡ç½®ä¸ºé»˜è®¤å€¼', 'info');
    }

    // ==================== çŠ¶æ€æç¤º ====================
    function showStatus(message, type = 'info') {
        const bar = document.getElementById('statusBar');
        const colors = {
            success: 'bg-green-50 text-green-700 border border-green-200',
            error: 'bg-red-50 text-red-700 border border-red-200',
            warning: 'bg-yellow-50 text-yellow-700 border border-yellow-200',
            info: 'bg-blue-50 text-blue-700 border border-blue-200'
        };
        bar.className = `mb-4 px-4 py-3 rounded-lg text-sm fade-in ${colors[type] || colors.info}`;
        bar.textContent = message;
        bar.classList.remove('hidden');

        if (type !== 'error') {
            setTimeout(() => bar.classList.add('hidden'), 3000);
        }
    }

    // ==================== æ¸²æŸ“å‡½æ•° ====================
    function renderAll() {
        renderMappings();
        renderCustomRules();
        updatePreview();
        updateButtons();
    }

    function renderMappings() {
        const tbody = document.getElementById('mappingTableBody');
        const emptyState = document.getElementById('emptyState');

        if (state.mappings.length === 0) {
            tbody.innerHTML = '';
            emptyState.classList.remove('hidden');
            return;
        }

        emptyState.classList.add('hidden');
        tbody.innerHTML = state.mappings.map((m, i) => `
            <tr class="mapping-row fade-in ${m.checked ? 'checked' : ''}" data-index="${i}">
                <td class="px-4 py-3">
                    <input type="checkbox" class="mapping-check w-4 h-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500" ${m.checked ? 'checked' : ''}>
                </td>
                <td class="px-4 py-3">
                    <input type="text" value="${escapeHtml(m.source)}" class="source-input w-full border border-gray-300 rounded px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="æºæ¨¡å‹">
                </td>
                <td class="px-4 py-3 text-center text-gray-400">â†’</td>
                <td class="px-4 py-3">
                    <input type="text" value="${escapeHtml(m.target)}" class="target-input w-full border border-gray-300 rounded px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="ç›®æ ‡æ¨¡å‹">
                </td>
                <td class="px-4 py-3">
                    <button class="delete-btn text-red-600 hover:text-red-700 transition" title="åˆ é™¤">
                        <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                        </svg>
                    </button>
                </td>
            </tr>
        `).join('');

        // ç»‘å®šäº‹ä»¶
        tbody.querySelectorAll('.mapping-row').forEach(row => {
            const index = parseInt(row.dataset.index);
            const checkbox = row.querySelector('.mapping-check');
            const sourceInput = row.querySelector('.source-input');
            const targetInput = row.querySelector('.target-input');
            const deleteBtn = row.querySelector('.delete-btn');

            checkbox?.addEventListener('change', () => {
                state.mappings[index].checked = checkbox.checked;
                row.classList.toggle('checked', checkbox.checked);
                updateButtons();
            });

            sourceInput?.addEventListener('input', () => {
                state.mappings[index].source = sourceInput.value;
                updatePreview();
            });

            targetInput?.addEventListener('input', () => {
                state.mappings[index].target = targetInput.value;
                updatePreview();
            });

            deleteBtn?.addEventListener('click', () => {
                state.mappings.splice(index, 1);
                renderMappings();
                updatePreview();
                updateButtons();
            });
        });
    }

    function renderCustomRules() {
        const container = document.getElementById('customRulesList');
        if (state.customRules.length === 0) {
            container.innerHTML = '<p class="text-sm text-gray-400 text-center py-4">æš‚æ— è‡ªå®šä¹‰è§„åˆ™</p>';
            return;
        }

        container.innerHTML = state.customRules.map((r, i) => `
            <div class="flex items-center justify-between p-2 bg-gray-50 rounded text-sm slide-in">
                <div class="flex items-center gap-2 overflow-hidden">
                    <span class="px-1.5 py-0.5 bg-blue-100 text-blue-700 rounded text-xs font-mono">${r.type}</span>
                    <span class="text-gray-600 truncate" title="${escapeHtml(r.pattern)}">${escapeHtml(r.pattern)}</span>
                    <span class="text-gray-400">â†’</span>
                    <span class="text-gray-800 font-medium truncate" title="${escapeHtml(r.target)}">${escapeHtml(r.target)}</span>
                </div>
                <button class="delete-rule-btn text-red-600 hover:text-red-700 transition" data-index="${i}">
                    <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>
        `).join('');

        container.querySelectorAll('.delete-rule-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const index = parseInt(btn.dataset.index);
                state.customRules.splice(index, 1);
                renderCustomRules();
                updatePreview();
            });
        });
    }

    function updatePreview() {
        const previewArea = document.getElementById('previewArea');
        const previewCount = document.getElementById('previewCount');
        const changes = generatePreview();

        if (changes.length === 0) {
            previewArea.innerHTML = '<span class="text-gray-400">æš‚æ— é¢„è§ˆ</span>';
            previewCount.textContent = '0 å¤„å˜æ›´';
            return;
        }

        previewArea.innerHTML = changes.map(c => `
            <div class="py-1 border-b border-gray-200 last:border-0">
                <span class="text-red-600">${escapeHtml(c.source)}</span>
                <span class="text-gray-400 mx-1">â†’</span>
                <span class="text-green-600">${escapeHtml(c.target)}</span>
            </div>
        `).join('');

        previewCount.textContent = `${changes.length} å¤„å˜æ›´`;
    }

    function updateButtons() {
        const checkedCount = state.mappings.filter(m => m.checked).length;
        document.getElementById('deleteSelectedBtn').disabled = checkedCount === 0;
        document.getElementById('syncBtn').disabled = state.mappings.length === 0;
        document.getElementById('checkpointBtn').disabled = state.mappings.length === 0;
    }

    // ==================== è§„åˆ™å¼•æ“ ====================
    function generatePreview() {
        const mappings = [];
        const processed = new Set();

        // é“¾å¼æ˜ å°„
        const getFinalTarget = (source) => {
            if (!state.rules.chainMapping) return source;
            const direct = state.mappings.find(m => m.source === source);
            if (!direct) return source;
            if (direct.target === source) return source;
            return getFinalTarget(direct.target);
        };

        // è‡ªå®šä¹‰è§„åˆ™
        const applyCustomRules = (model) => {
            for (const rule of state.customRules) {
                if (!rule.enabled && rule.enabled !== undefined) continue;
                let match = false;
                switch (rule.type) {
                    case 'string': match = model === rule.pattern; break;
                    case 'prefix': match = model.startsWith(rule.pattern); break;
                    case 'suffix': match = model.endsWith(rule.pattern); break;
                    case 'regex': try { match = new RegExp(rule.pattern).test(model); } catch (e) {} break;
                }
                if (match) return rule.target;
            }
            return model;
        };

        // å‰åç¼€æ¸…ç†
        const cleanup = (model) => {
            let result = model;
            if (state.rules.prefixCleanup) {
                result = result.replace(/^[\[\]ã€ã€‘\(\)<>][^\[\]ã€ã€‘\(\)<>]*[\]ã€ã€‘\(\)<>]\s*/g, '');
                result = result.replace(/^[^\[\]ã€ã€‘\(\)<>]*[\]ã€ã€‘\(\)<>]\s*/g, '');
            }
            if (state.rules.suffixCleanup) {
                result = result.replace(/\s*[\[\]ã€ã€‘\(\)<>][^\[\]ã€ã€‘\(\)<>]*[\]ã€ã€‘\(\)<>]$/g, '');
                result = result.replace(/\s*[_\-â€“â€”][vV]?\d+(\.\d+)*(\s*[-â€“â€”]\S+)?$/g, '');
                result = result.replace(/\s*\([^)]*\)$/g, '');
            }
            return result.trim();
        };

        // é€šé…ç¬¦åŒ¹é…
        const wildcardMatch = (source, target) => {
            if (!state.rules.wildcardMode) return source === target;
            const pattern = target.replace(/\*/g, '.*');
            try {
                const regex = new RegExp(`^${pattern}$`, 'i');
                return regex.test(source);
            } catch (e) {
                return source === target;
            }
        };

        // ç”Ÿæˆé¢„è§ˆ
        for (const m of state.mappings) {
            if (!m.source || processed.has(m.source)) continue;

            let source = m.source;
            let target = m.target;

            // åº”ç”¨æ¸…ç†
            if (state.rules.prefixCleanup || state.rules.suffixCleanup) {
                source = cleanup(source);
            }

            // åº”ç”¨è‡ªå®šä¹‰è§„åˆ™
            target = applyCustomRules(target);

            // å¤„ç†æ•°ç»„æ˜ å°„
            if (Array.isArray(target)) {
                target = target[0];
            }

            // é“¾å¼æ˜ å°„
            if (state.rules.chainMapping) {
                target = getFinalTarget(target);
            }

            if (source !== target) {
                mappings.push({ source: m.source, target: target });
            }

            processed.add(m.source);
        }

        return mappings;
    }

    // ==================== API è°ƒç”¨ ====================
    const API_BASE = '/api';

    async function fetchChannels() {
        try {
            const res = await fetch(`${API_BASE}/channels`);
            if (!res.ok) throw new Error('è·å–æ¸ é“åˆ—è¡¨å¤±è´¥');
            return await res.json();
        } catch (e) {
            console.error('API é”™è¯¯:', e);
            showStatus('è·å–æ¸ é“åˆ—è¡¨å¤±è´¥: ' + e.message, 'error');
            return [];
        }
    }

    async function fetchChannelDetail(id) {
        try {
            const res = await fetch(`${API_BASE}/channel-detail`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id })
            });
            if (!res.ok) throw new Error('è·å–æ¸ é“è¯¦æƒ…å¤±è´¥');
            return await res.json();
        } catch (e) {
            console.error('API é”™è¯¯:', e);
            showStatus('è·å–æ¸ é“è¯¦æƒ…å¤±è´¥: ' + e.message, 'error');
            return null;
        }
    }

    async function syncModels(channelId, mappings) {
        try {
            const res = await fetch(`${API_BASE}/sync-models`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: channelId, model_mapping: mappings })
            });
            if (!res.ok) throw new Error('åŒæ­¥å¤±è´¥');
            return await res.json();
        } catch (e) {
            console.error('API é”™è¯¯:', e);
            showStatus('åŒæ­¥å¤±è´¥: ' + e.message, 'error');
            return null;
        }
    }

    async function createCheckpoint(channelId, name) {
        try {
            const res = await fetch(`${API_BASE}/checkpoint/create`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ channelId, name: name || `å¤‡ä»½ ${new Date().toLocaleString()}` })
            });
            if (!res.ok) throw new Error('åˆ›å»ºæ£€æŸ¥ç‚¹å¤±è´¥');
            return await res.json();
        } catch (e) {
            console.error('API é”™è¯¯:', e);
            showStatus('åˆ›å»ºæ£€æŸ¥ç‚¹å¤±è´¥: ' + e.message, 'error');
            return null;
        }
    }

    // ==================== äº‹ä»¶ç»‘å®š ====================
    function bindEvents() {
        // ä¿å­˜
        document.getElementById('saveBtn')?.addEventListener('click', () => {
            saveState();
        });

        // é‡ç½®
        document.getElementById('resetBtn')?.addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰è®¾ç½®å—ï¼Ÿ')) {
                resetState();
            }
        });

        // å…¨é€‰
        document.getElementById('selectAll')?.addEventListener('change', (e) => {
            state.mappings.forEach(m => m.checked = e.target.checked);
            renderMappings();
            updateButtons();
        });

        // åé€‰
        document.getElementById('inverseBtn')?.addEventListener('click', () => {
            state.mappings.forEach(m => m.checked = !m.checked);
            renderMappings();
            updateButtons();
        });

        // åˆ é™¤é€‰ä¸­
        document.getElementById('deleteSelectedBtn')?.addEventListener('click', () => {
            const checked = state.mappings.filter(m => m.checked);
            if (checked.length === 0) return;
            if (confirm(`ç¡®å®šåˆ é™¤é€‰ä¸­çš„ ${checked.length} æ¡æ˜ å°„å—ï¼Ÿ`)) {
                state.mappings = state.mappings.filter(m => !m.checked);
                renderMappings();
                updatePreview();
                updateButtons();
            }
        });

        // æ·»åŠ æ˜ å°„
        document.getElementById('addMappingBtn')?.addEventListener('click', () => {
            state.mappings.unshift({ source: '', target: '', checked: false });
            renderMappings();
            updatePreview();
            updateButtons();
        });

        // è§„åˆ™å¼€å…³
        ['prefixCleanup', 'suffixCleanup', 'wildcardMode', 'chainMapping'].forEach(id => {
            document.getElementById(id)?.addEventListener('change', (e) => {
                state.rules[id] = e.target.checked;
                updatePreview();
            });
        });

        // æ·»åŠ è§„åˆ™
        document.getElementById('addRuleBtn')?.addEventListener('click', () => {
            document.getElementById('ruleModal').classList.remove('hidden');
            document.getElementById('rulePattern').value = '';
            document.getElementById('ruleTarget').value = '';
        });

        // é¢„è§ˆ
        document.getElementById('previewBtn')?.addEventListener('click', () => {
            updatePreview();
            showStatus(`é¢„è§ˆå®Œæˆï¼Œå…± ${generatePreview().length} å¤„å˜æ›´`, 'success');
        });

        // å¯¼å…¥
        document.getElementById('importBtn')?.addEventListener('click', () => {
            document.getElementById('importModal').classList.remove('hidden');
            document.getElementById('importText').value = '';
        });

        // å¯¼å‡º
        document.getElementById('exportBtn')?.addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `model-mappings-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showStatus('å·²å¯¼å‡ºé…ç½®', 'success');
        });

        // è§„åˆ™å¼¹çª—
        document.getElementById('cancelRuleBtn')?.addEventListener('click', () => {
            document.getElementById('ruleModal').classList.add('hidden');
        });

        document.getElementById('saveRuleBtn')?.addEventListener('click', () => {
            const type = document.getElementById('ruleType').value;
            const pattern = document.getElementById('rulePattern').value.trim();
            const target = document.getElementById('ruleTarget').value.trim();

            if (!pattern || !target) {
                showStatus('è¯·å¡«å†™è§„åˆ™å†…å®¹', 'warning');
                return;
            }

            state.customRules.push({ type, pattern, target });
            renderCustomRules();
            updatePreview();
            document.getElementById('ruleModal').classList.add('hidden');
            showStatus('è§„åˆ™å·²æ·»åŠ ', 'success');
        });

        // å¯¼å…¥å¼¹çª—
        document.getElementById('cancelImportBtn')?.addEventListener('click', () => {
            document.getElementById('importModal').classList.add('hidden');
        });

        document.getElementById('confirmImportBtn')?.addEventListener('click', () => {
            try {
                const imported = JSON.parse(document.getElementById('importText').value);
                if (imported.mappings) state.mappings = imported.mappings;
                if (imported.rules) state.rules = imported.rules;
                if (imported.customRules) state.customRules = imported.customRules;
                renderAll();
                document.getElementById('importModal').classList.add('hidden');
                showStatus(`å·²å¯¼å…¥ ${imported.mappings?.length || 0} æ¡æ˜ å°„`, 'success');
            } catch (e) {
                showStatus('JSON æ ¼å¼é”™è¯¯', 'error');
            }
        });

        // åŒæ­¥
        document.getElementById('syncBtn')?.addEventListener('click', async () => {
            const channelId = document.getElementById('channelSelect').value;
            if (!channelId) {
                showStatus('è¯·é€‰æ‹©æ¸ é“', 'warning');
                return;
            }

            const mappings = {};
            state.mappings.forEach(m => {
                if (m.source && m.target) mappings[m.source] = m.target;
            });

            showStatus('åŒæ­¥ä¸­...', 'info');
            const result = await syncModels(channelId, mappings);
            if (result) {
                showStatus('åŒæ­¥æˆåŠŸ', 'success');
            }
        });

        // æ£€æŸ¥ç‚¹
        document.getElementById('checkpointBtn')?.addEventListener('click', async () => {
            const channelId = document.getElementById('channelSelect').value;
            if (!channelId) {
                showStatus('è¯·é€‰æ‹©æ¸ é“', 'warning');
                return;
            }

            const name = prompt('æ£€æŸ¥ç‚¹åç§°:', `å¤‡ä»½ ${new Date().toLocaleString()}`);
            if (!name) return;

            const result = await createCheckpoint(channelId, name);
            if (result) {
                showStatus('æ£€æŸ¥ç‚¹å·²åˆ›å»º', 'success');
            }
        });

        // æ¸ é“é€‰æ‹©
        document.getElementById('channelSelect')?.addEventListener('change', async (e) => {
            const channelId = e.target.value;
            if (!channelId) return;

            showStatus('åŠ è½½æ¸ é“æ•°æ®...', 'info');
            const detail = await fetchChannelDetail(channelId);
            if (detail && detail.model_mapping) {
                try {
                    const mappings = typeof detail.model_mapping === 'string'
                        ? JSON.parse(detail.model_mapping)
                        : detail.model_mapping;

                    state.mappings = Object.entries(mappings).map(([source, target]) => ({
                        source,
                        target: Array.isArray(target) ? target[0] : target,
                        checked: false
                    }));
                    renderMappings();
                    updatePreview();
                    showStatus(`å·²åŠ è½½ ${state.mappings.length} æ¡æ˜ å°„`, 'success');
                } catch (e) {
                    showStatus('è§£ææ˜ å°„æ•°æ®å¤±è´¥', 'error');
                }
            } else {
                showStatus('è¯¥æ¸ é“æ— æ˜ å°„æ•°æ®', 'info');
            }
        });
    }

    // ==================== å·¥å…·å‡½æ•° ====================
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // ==================== åˆå§‹åŒ– ====================
    async function init() {
        renderAll();
        bindEvents();

        // åŠ è½½æ¸ é“åˆ—è¡¨
        const channels = await fetchChannels();
        const select = document.getElementById('channelSelect');
        if (channels.length > 0) {
            select.innerHTML = '<option value="">é€‰æ‹©æ¸ é“...</option>' +
                channels.map(c => `<option value="${c.id}">${c.name || c.id}</option>`).join('');
        }

        showStatus('é¡µé¢å·²åŠ è½½', 'success');
    }

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    </script>
</body>
</html>
